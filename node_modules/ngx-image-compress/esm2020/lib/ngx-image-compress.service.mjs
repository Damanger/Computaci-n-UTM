import { Injectable } from '@angular/core';
import { ImageCompress } from './image-compress';
import { DOC_ORIENTATION } from './models/DOC_ORIENTATION';
import * as i0 from "@angular/core";
export class NgxImageCompressService {
    constructor(rendererFactory) {
        this.DOC_ORIENTATION = DOC_ORIENTATION;
        this.render = rendererFactory.createRenderer(null, null);
    }
    /**
     * helper to evaluate the compression rate
     * @param imgString the image in base64 string format
     */
    byteCount(image) {
        return ImageCompress.byteCount(image);
    }
    /**
     * Get the correct Orientation value from image tags
     */
    getOrientation(file) {
        return ImageCompress.getOrientation(file);
    }
    /**
     * return a promise with the new image data and image orientation
     * Nothing happen if no file have been selected
     */
    uploadFile() {
        return ImageCompress.uploadFile(this.render, false);
    }
    /**
     * return a promise with an array of image data and image orientation
     * Nothing happen if no files have been selected
     */
    uploadMultipleFiles() {
        return ImageCompress.uploadFile(this.render, true);
    }
    /**
     * return a promise with the new image data and image orientation
     * the promise will reject if no file have been selected
     */
    uploadFileOrReject() {
        return ImageCompress.uploadFile(this.render, false, true);
    }
    /**
     * return a promise with an array of image data and image orientation
     * the promise will reject if no files have been selected
     */
    uploadMultipleFilesOrReject() {
        return ImageCompress.uploadFile(this.render, true, true);
    }
    /**
   * perform a compression from the given DataUrl (string), provided by the uploadFile, or uploadMultipleFiles method
   *
   *
   | Parameter   | Type   | Description                                                                       |
   | ----------- | ------ | --------------------------------------------------------------------------------- |
   | image       | string | DataUrl (string) representing the image                                           |
   | orientation | number | EXIF Orientation value using the DOC_ORIENTATION enum value                       |
   | ratio       | number | Maximum scale factor as a percentage (optional, default: 50) <sup>[1](#fn1)</sup> |
   | quality     | number | JPEG quality factor as a percentage (optional, default: 50) <sup>[2](#fn2)</sup>  |
   | maxwidth    | number | Maximum width in pixels if you need to resize (optional, default: 0 - no resize)  |
   | maxheight   | number | Maximum height in pixels if you need to resize (optional, default: 0 - no resize) |
   */
    compressFile(image, orientation, ratio = 50, quality = 50, maxWidth = 0, maxHeight = 0) {
        return ImageCompress.compress(image, orientation, this.render, ratio, quality, maxWidth, maxHeight);
    }
    /**
     * Most simple function to use here.
     * Perform an upload and return an image dataUrl (string format) with a maximum size, given in *MegaBytes*
     * If the size can't be reached, the best that can be reached will be returned in promise *rejection*
     * Put debugMode to true if you have some trouble to print some help using console.debug
     */
    uploadAndGetImageWithMaxSize(maxSizeMb = 1, debugMode = false, rejectOnCancel = false) {
        return ImageCompress.getImageMaxSize(maxSizeMb, debugMode, this.render, rejectOnCancel);
    }
}
NgxImageCompressService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.1.2", ngImport: i0, type: NgxImageCompressService, deps: [{ token: i0.RendererFactory2 }], target: i0.ɵɵFactoryTarget.Injectable });
NgxImageCompressService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.1.2", ngImport: i0, type: NgxImageCompressService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.1.2", ngImport: i0, type: NgxImageCompressService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.RendererFactory2 }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWltYWdlLWNvbXByZXNzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtaW1hZ2UtY29tcHJlc3Mvc3JjL2xpYi9uZ3gtaW1hZ2UtY29tcHJlc3Muc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsVUFBVSxFQUE4QixNQUFNLGVBQWUsQ0FBQztBQUN0RSxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDL0MsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLDBCQUEwQixDQUFDOztBQU96RCxNQUFNLE9BQU8sdUJBQXVCO0lBS2hDLFlBQVksZUFBaUM7UUFGdEMsb0JBQWUsR0FBRyxlQUFlLENBQUM7UUFHckMsSUFBSSxDQUFDLE1BQU0sR0FBRyxlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksU0FBUyxDQUFDLEtBQWM7UUFDM0IsT0FBTyxhQUFhLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRDs7T0FFRztJQUNJLGNBQWMsQ0FBQyxJQUFVO1FBQzVCLE9BQU8sYUFBYSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksVUFBVTtRQUNiLE9BQU8sYUFBYSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBNEIsQ0FBQztJQUNuRixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksbUJBQW1CO1FBQ3RCLE9BQU8sYUFBYSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBOEIsQ0FBQztJQUNwRixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksa0JBQWtCO1FBQ3JCLE9BQU8sYUFBYSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQTRCLENBQUM7SUFDekYsQ0FBQztJQUVEOzs7T0FHRztJQUNJLDJCQUEyQjtRQUM5QixPQUFPLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUE4QixDQUFDO0lBQzFGLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O0tBWUM7SUFDTSxZQUFZLENBQ2YsS0FBYyxFQUNkLFdBQTRCLEVBQzVCLFFBQWdCLEVBQUUsRUFDbEIsVUFBa0IsRUFBRSxFQUNwQixXQUFtQixDQUFDLEVBQ3BCLFlBQW9CLENBQUM7UUFFckIsT0FBTyxhQUFhLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN4RyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSw0QkFBNEIsQ0FBQyxZQUFvQixDQUFDLEVBQUUsU0FBUyxHQUFHLEtBQUssRUFBRSxjQUFjLEdBQUcsS0FBSztRQUNoRyxPQUFPLGFBQWEsQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxDQUFDO0lBQzVGLENBQUM7O29IQXhGUSx1QkFBdUI7d0hBQXZCLHVCQUF1QixjQUZwQixNQUFNOzJGQUVULHVCQUF1QjtrQkFIbkMsVUFBVTttQkFBQztvQkFDUixVQUFVLEVBQUUsTUFBTTtpQkFDckIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdGFibGUsIFJlbmRlcmVyMiwgUmVuZGVyZXJGYWN0b3J5Mn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0ltYWdlQ29tcHJlc3N9IGZyb20gJy4vaW1hZ2UtY29tcHJlc3MnO1xuaW1wb3J0IHtET0NfT1JJRU5UQVRJT059IGZyb20gJy4vbW9kZWxzL0RPQ19PUklFTlRBVElPTic7XG5pbXBvcnQge1VwbG9hZFJlc3BvbnNlfSBmcm9tICcuL21vZGVscy91cGxvYWQtcmVzcG9uc2UnO1xuaW1wb3J0IHtEYXRhVXJsfSBmcm9tICcuL21vZGVscy9kYXRhLXVybCc7XG5cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIE5neEltYWdlQ29tcHJlc3NTZXJ2aWNlIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlbmRlcjogUmVuZGVyZXIyO1xuXG4gICAgcHVibGljIERPQ19PUklFTlRBVElPTiA9IERPQ19PUklFTlRBVElPTjtcblxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyRmFjdG9yeTogUmVuZGVyZXJGYWN0b3J5Mikge1xuICAgICAgICB0aGlzLnJlbmRlciA9IHJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoZWxwZXIgdG8gZXZhbHVhdGUgdGhlIGNvbXByZXNzaW9uIHJhdGVcbiAgICAgKiBAcGFyYW0gaW1nU3RyaW5nIHRoZSBpbWFnZSBpbiBiYXNlNjQgc3RyaW5nIGZvcm1hdFxuICAgICAqL1xuICAgIHB1YmxpYyBieXRlQ291bnQoaW1hZ2U6IERhdGFVcmwpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlQ29tcHJlc3MuYnl0ZUNvdW50KGltYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvcnJlY3QgT3JpZW50YXRpb24gdmFsdWUgZnJvbSBpbWFnZSB0YWdzXG4gICAgICovXG4gICAgcHVibGljIGdldE9yaWVudGF0aW9uKGZpbGU6IEZpbGUpOiBQcm9taXNlPERPQ19PUklFTlRBVElPTj4ge1xuICAgICAgICByZXR1cm4gSW1hZ2VDb21wcmVzcy5nZXRPcmllbnRhdGlvbihmaWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSBwcm9taXNlIHdpdGggdGhlIG5ldyBpbWFnZSBkYXRhIGFuZCBpbWFnZSBvcmllbnRhdGlvblxuICAgICAqIE5vdGhpbmcgaGFwcGVuIGlmIG5vIGZpbGUgaGF2ZSBiZWVuIHNlbGVjdGVkXG4gICAgICovXG4gICAgcHVibGljIHVwbG9hZEZpbGUoKTogUHJvbWlzZTxVcGxvYWRSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gSW1hZ2VDb21wcmVzcy51cGxvYWRGaWxlKHRoaXMucmVuZGVyLCBmYWxzZSkgYXMgUHJvbWlzZTxVcGxvYWRSZXNwb25zZT47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgcHJvbWlzZSB3aXRoIGFuIGFycmF5IG9mIGltYWdlIGRhdGEgYW5kIGltYWdlIG9yaWVudGF0aW9uXG4gICAgICogTm90aGluZyBoYXBwZW4gaWYgbm8gZmlsZXMgaGF2ZSBiZWVuIHNlbGVjdGVkXG4gICAgICovXG4gICAgcHVibGljIHVwbG9hZE11bHRpcGxlRmlsZXMoKTogUHJvbWlzZTxVcGxvYWRSZXNwb25zZVtdPiB7XG4gICAgICAgIHJldHVybiBJbWFnZUNvbXByZXNzLnVwbG9hZEZpbGUodGhpcy5yZW5kZXIsIHRydWUpIGFzIFByb21pc2U8VXBsb2FkUmVzcG9uc2VbXT47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgcHJvbWlzZSB3aXRoIHRoZSBuZXcgaW1hZ2UgZGF0YSBhbmQgaW1hZ2Ugb3JpZW50YXRpb25cbiAgICAgKiB0aGUgcHJvbWlzZSB3aWxsIHJlamVjdCBpZiBubyBmaWxlIGhhdmUgYmVlbiBzZWxlY3RlZFxuICAgICAqL1xuICAgIHB1YmxpYyB1cGxvYWRGaWxlT3JSZWplY3QoKTogUHJvbWlzZTxVcGxvYWRSZXNwb25zZT4ge1xuICAgICAgICByZXR1cm4gSW1hZ2VDb21wcmVzcy51cGxvYWRGaWxlKHRoaXMucmVuZGVyLCBmYWxzZSwgdHJ1ZSkgYXMgUHJvbWlzZTxVcGxvYWRSZXNwb25zZT47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgcHJvbWlzZSB3aXRoIGFuIGFycmF5IG9mIGltYWdlIGRhdGEgYW5kIGltYWdlIG9yaWVudGF0aW9uXG4gICAgICogdGhlIHByb21pc2Ugd2lsbCByZWplY3QgaWYgbm8gZmlsZXMgaGF2ZSBiZWVuIHNlbGVjdGVkXG4gICAgICovXG4gICAgcHVibGljIHVwbG9hZE11bHRpcGxlRmlsZXNPclJlamVjdCgpOiBQcm9taXNlPFVwbG9hZFJlc3BvbnNlW10+IHtcbiAgICAgICAgcmV0dXJuIEltYWdlQ29tcHJlc3MudXBsb2FkRmlsZSh0aGlzLnJlbmRlciwgdHJ1ZSwgdHJ1ZSkgYXMgUHJvbWlzZTxVcGxvYWRSZXNwb25zZVtdPjtcbiAgICB9XG5cbiAgICAvKipcbiAgICogcGVyZm9ybSBhIGNvbXByZXNzaW9uIGZyb20gdGhlIGdpdmVuIERhdGFVcmwgKHN0cmluZyksIHByb3ZpZGVkIGJ5IHRoZSB1cGxvYWRGaWxlLCBvciB1cGxvYWRNdWx0aXBsZUZpbGVzIG1ldGhvZFxuICAgKlxuICAgKlxuICAgfCBQYXJhbWV0ZXIgICB8IFR5cGUgICB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICB8IC0tLS0tLS0tLS0tIHwgLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHxcbiAgIHwgaW1hZ2UgICAgICAgfCBzdHJpbmcgfCBEYXRhVXJsIChzdHJpbmcpIHJlcHJlc2VudGluZyB0aGUgaW1hZ2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgfCBvcmllbnRhdGlvbiB8IG51bWJlciB8IEVYSUYgT3JpZW50YXRpb24gdmFsdWUgdXNpbmcgdGhlIERPQ19PUklFTlRBVElPTiBlbnVtIHZhbHVlICAgICAgICAgICAgICAgICAgICAgICB8XG4gICB8IHJhdGlvICAgICAgIHwgbnVtYmVyIHwgTWF4aW11bSBzY2FsZSBmYWN0b3IgYXMgYSBwZXJjZW50YWdlIChvcHRpb25hbCwgZGVmYXVsdDogNTApIDxzdXA+WzFdKCNmbjEpPC9zdXA+IHxcbiAgIHwgcXVhbGl0eSAgICAgfCBudW1iZXIgfCBKUEVHIHF1YWxpdHkgZmFjdG9yIGFzIGEgcGVyY2VudGFnZSAob3B0aW9uYWwsIGRlZmF1bHQ6IDUwKSA8c3VwPlsyXSgjZm4yKTwvc3VwPiAgfFxuICAgfCBtYXh3aWR0aCAgICB8IG51bWJlciB8IE1heGltdW0gd2lkdGggaW4gcGl4ZWxzIGlmIHlvdSBuZWVkIHRvIHJlc2l6ZSAob3B0aW9uYWwsIGRlZmF1bHQ6IDAgLSBubyByZXNpemUpICB8XG4gICB8IG1heGhlaWdodCAgIHwgbnVtYmVyIHwgTWF4aW11bSBoZWlnaHQgaW4gcGl4ZWxzIGlmIHlvdSBuZWVkIHRvIHJlc2l6ZSAob3B0aW9uYWwsIGRlZmF1bHQ6IDAgLSBubyByZXNpemUpIHxcbiAgICovXG4gICAgcHVibGljIGNvbXByZXNzRmlsZShcbiAgICAgICAgaW1hZ2U6IERhdGFVcmwsXG4gICAgICAgIG9yaWVudGF0aW9uOiBET0NfT1JJRU5UQVRJT04sXG4gICAgICAgIHJhdGlvOiBudW1iZXIgPSA1MCxcbiAgICAgICAgcXVhbGl0eTogbnVtYmVyID0gNTAsXG4gICAgICAgIG1heFdpZHRoOiBudW1iZXIgPSAwLFxuICAgICAgICBtYXhIZWlnaHQ6IG51bWJlciA9IDBcbiAgICApOiBQcm9taXNlPERhdGFVcmw+IHtcbiAgICAgICAgcmV0dXJuIEltYWdlQ29tcHJlc3MuY29tcHJlc3MoaW1hZ2UsIG9yaWVudGF0aW9uLCB0aGlzLnJlbmRlciwgcmF0aW8sIHF1YWxpdHksIG1heFdpZHRoLCBtYXhIZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vc3Qgc2ltcGxlIGZ1bmN0aW9uIHRvIHVzZSBoZXJlLlxuICAgICAqIFBlcmZvcm0gYW4gdXBsb2FkIGFuZCByZXR1cm4gYW4gaW1hZ2UgZGF0YVVybCAoc3RyaW5nIGZvcm1hdCkgd2l0aCBhIG1heGltdW0gc2l6ZSwgZ2l2ZW4gaW4gKk1lZ2FCeXRlcypcbiAgICAgKiBJZiB0aGUgc2l6ZSBjYW4ndCBiZSByZWFjaGVkLCB0aGUgYmVzdCB0aGF0IGNhbiBiZSByZWFjaGVkIHdpbGwgYmUgcmV0dXJuZWQgaW4gcHJvbWlzZSAqcmVqZWN0aW9uKlxuICAgICAqIFB1dCBkZWJ1Z01vZGUgdG8gdHJ1ZSBpZiB5b3UgaGF2ZSBzb21lIHRyb3VibGUgdG8gcHJpbnQgc29tZSBoZWxwIHVzaW5nIGNvbnNvbGUuZGVidWdcbiAgICAgKi9cbiAgICBwdWJsaWMgdXBsb2FkQW5kR2V0SW1hZ2VXaXRoTWF4U2l6ZShtYXhTaXplTWI6IG51bWJlciA9IDEsIGRlYnVnTW9kZSA9IGZhbHNlLCByZWplY3RPbkNhbmNlbCA9IGZhbHNlKTogUHJvbWlzZTxEYXRhVXJsPiB7XG4gICAgICAgIHJldHVybiBJbWFnZUNvbXByZXNzLmdldEltYWdlTWF4U2l6ZShtYXhTaXplTWIsIGRlYnVnTW9kZSwgdGhpcy5yZW5kZXIsIHJlamVjdE9uQ2FuY2VsKTtcbiAgICB9XG59XG4iXX0=